# 磁力计数据读取--以IST8310为例

>   这里以iSentek公司产出的IST8310型号的磁力计为例，尺寸为 3.0 * 3.0 * 1.0mm，支持快速 I2C 通信，可达 400kHz，14 位磁场数据，测量范围可达1600uT(x,y-axis)和 2500uT(z-axis)， 最高 200Hz 输出频率
>
>   IST8310的数据手册附在文件夹里面，可以自行阅读
>
>   同时这里的磁力计是安装在大疆公司出产的RoboMaster开发板C型，单片机芯片是STM32F407IGH6，其外围电路已经设计好，只需要读取磁力计数据即可。
>
>   本篇不会介绍SPI、I2C等嵌入式通信协议，需要有一定嵌入式开发基础的同学来看（可以去看底层中介绍的STM32开发视频）
>
>   文末附代码

## 零、数据手册分析

第一章讲了IST8310的特性，I2C通信，最高支持400kHz通信速率，14位或者16位自适应数据输出等特性

![image-20221203143646334](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/da226446da7fcaee1ce99caff4d83dfc/202212031436422.png)

第二章讲了内部结构

![image-20221203143810184](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/291fb3c4f176523a3c1f66ad38fd5059/202212031438276.png)

第三章讲了电气特性

![image-20221203143859175](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/35b72a9b8889305a0a415be93579f5fb/202212031438257.png)

第四章讲了如何联系他们

![image-20221203144121246](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/95e980ed64eef2e6129e82d1c85885cc/202212031441334.png)

然后数据手册就没了。。。在大疆的开发手册中找到了寄存器的手册，如下：

![image-20221203165413897](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/9ea3603f10c8c8fc1d77715718ef3500/202212031654976.png)

![image-20221203165444657](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/80f0e5afea94b9dc2990dd66f5b9feb9/202212031654708.png)

![image-20221203165507558](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/c70dbd0bf2cf67fc659a693b75203cc3/202212031655613.png)

![image-20221203165822701](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/c1000041c546b66ecf3a77af12908dc9/202212031658758.png)

![image-20221203165838781](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/b1145457e91b47ec38770c8f6740dcbb/202212031658841.png)

![image-20221203165849045](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/bb6710aa4baf8bf54b96c4ae7b7f18ec/202212031658081.png)

## 一、CubeMX配置

点开I2C配置选项， 下图是配好的：

![image-20221203165955297](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/52844b661dcd5f54ccc98c9e627fb0b6/202212031659341.png)

观察IST8310的数据手册，发现其支持最大400kHz的I2C通信速率，也就是快速I2C模式，所以第一行I2C Speed Mode我们选Fast Mode

![image-20221203170120553](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/49dde875369d460e7251f2370261cf8f/202212031701605.png)

同时不要忘记了在C板中I2C3的两个IO口分别是PA8和PC9（一般来说都是这两个）

![image-20221203170657996](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/26fc7c45bfd54f6e072305c8cf9ccf7a/202212031706056.png)

之后观察大疆和IST8310的数据手册，发现控制IST8310重启的是PG6的GPIO口，低电平为重启，所以我们将其设置为高电平上拉输出模式

![image-20221203170402663](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/0d9a30634fe7c14bd89e48d7594e7e13/202212031704740.png)

![image-20221203170428263](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/a909c1c3618336b94a78ef733de697e1/202212031704343.png)

![image-20221203170517446](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/d8f10e8677bd4a615e0256ecc85541b5/202212031705527.png)

![image-20221203170602068](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/1064af782676ae0087ee71d79a021e83/202212031706120.png)

因为我们读取IST8310的程序运行在1kHz的freertos线程中，无需使用中断方式，所以我们不配置中断口



## 二、数据读取

总代码附在文末，这里放一些核心函数

IST8310初始化：

```C
void IST8310_INIT(ist8310_data_t* ist8310_data) {
    memset(ist8310_data, 0, sizeof(ist8310_data_t));

    ist8310_data->meg_error = IST8310_NO_ERROR;

    // 把磁力计重启
    HAL_GPIO_WritePin(IST8310_GPIOx, IST8310_GPIOp, GPIO_PIN_RESET);
    HAL_Delay(50);
    HAL_GPIO_WritePin(IST8310_GPIOx, IST8310_GPIOp, GPIO_PIN_SET);
    HAL_Delay(50);

    // 基础配置
    // 不使能中断，直接读取
    WriteSingleDataFromIST8310(IST8310_CNTL2_ADDR, IST8310_STAT2_NONE_ALL);
    // 平均采样四次
    WriteSingleDataFromIST8310(IST8310_AVGCNTL_ADDR, IST8310_AVGCNTL_FOURTH);
    // 200Hz的输出频率
    WriteSingleDataFromIST8310(IST8310_CNTL1_ADDR, IST8310_CNTL1_CONTINUE);

    ist8310_data->meg_error |= VerifyMegId(&ist8310_data->chip_id);
}
```

读取单个数据：

```C
uint8_t ReadSingleDataFromIST8310(uint8_t addr) {
    uint8_t data;
    HAL_I2C_Mem_Read(&IST8310_I2C, (IST8310_I2C_ADDR << 1), addr, I2C_MEMADD_SIZE_8BIT, &data, 1, 10);
    return data;
}
```

读取多个数据：

```C
void ReadMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len) {
    HAL_I2C_Mem_Read(&IST8310_I2C, (IST8310_I2C_ADDR << 1), addr, I2C_MEMADD_SIZE_8BIT, data, len, 10);
}
```

写入单个数据：

```C
void WriteSingleDataFromIST8310(uint8_t addr, uint8_t data) {
    HAL_I2C_Mem_Write(&IST8310_I2C, (IST8310_I2C_ADDR << 1), addr, I2C_MEMADD_SIZE_8BIT, &data, 1, 10);
}
```

写入多个数据：

```C
void WriteMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len) {
    HAL_I2C_Mem_Write(&IST8310_I2C, (IST8310_I2C_ADDR << 1), addr, I2C_MEMADD_SIZE_8BIT, data, len, 10);
}
```

这里会发现一个比较有意思的事情，就是这里的地址都左移了一位，是因为根据I2C协议，[7:0]的一个字节的数据，前七位是地址，后一位是代表读或者写的位，这样子就需要把地址左移

读取磁力计数据：

```C
void ReadIST8310Data(ist8310_raw_data_t* meg_data) {
    uint8_t buf[6];
    int16_t temp_ist8310_data = 0;
    ReadMultiDataFromIST8310(IST8310_DATA_XL_ADDR, buf, 6);
    temp_ist8310_data = (int16_t)((buf[1] << 8) | buf[0]);
    meg_data->x = MAG_SEN * temp_ist8310_data;
    temp_ist8310_data = (int16_t)((buf[3] << 8) | buf[2]);
    meg_data->y = MAG_SEN * temp_ist8310_data;
    temp_ist8310_data = (int16_t)((buf[5] << 8) | buf[4]);
    meg_data->z = MAG_SEN * temp_ist8310_data;
}
```

这里乘了一个系数MAG_SEN，它的值是0.3，是将读取到的数据转化为单位为uT的磁场值

下面就是源码，把`IST8310_INIT()`函数放在程序开始的地方，然后剩下的读取函数放在不断执行的线程里，就可以得到磁力计数据了

`ist8310.c`

```C
/**
 * @Author         : Minghang Li
 * @Date           : 2022-12-03 14:29
 * @LastEditTime   : 2022-12-03 16:52
 * @Note           :
 * @Copyright(c)   : Minghang Li Copyright
 */
#include "ist8310.h"

#include <string.h>

#include "i2c.h"
#include "ist8310reg.h"

void IST8310_INIT(ist8310_data_t* ist8310_data) {
    memset(ist8310_data, 0, sizeof(ist8310_data_t));

    ist8310_data->meg_error = IST8310_NO_ERROR;

    // 把磁力计重启
    HAL_GPIO_WritePin(IST8310_GPIOx, IST8310_GPIOp, GPIO_PIN_RESET);
    HAL_Delay(50);
    HAL_GPIO_WritePin(IST8310_GPIOx, IST8310_GPIOp, GPIO_PIN_SET);
    HAL_Delay(50);

    // 基础配置
    // 不使能中断，直接读取
    WriteSingleDataFromIST8310(IST8310_CNTL2_ADDR, IST8310_STAT2_NONE_ALL);
    // 平均采样四次
    WriteSingleDataFromIST8310(IST8310_AVGCNTL_ADDR, IST8310_AVGCNTL_FOURTH);
    // 200Hz的输出频率
    WriteSingleDataFromIST8310(IST8310_CNTL1_ADDR, IST8310_CNTL1_CONTINUE);

    ist8310_data->meg_error |= VerifyMegId(&ist8310_data->chip_id);
}

uint8_t ReadSingleDataFromIST8310(uint8_t addr) {
    uint8_t data;
    HAL_I2C_Mem_Read(&IST8310_I2C, (IST8310_I2C_ADDR << 1), addr, I2C_MEMADD_SIZE_8BIT, &data, 1, 10);
    return data;
}

void WriteSingleDataFromIST8310(uint8_t addr, uint8_t data) {
    HAL_I2C_Mem_Write(&IST8310_I2C, (IST8310_I2C_ADDR << 1), addr, I2C_MEMADD_SIZE_8BIT, &data, 1, 10);
}

void ReadMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len) {
    HAL_I2C_Mem_Read(&IST8310_I2C, (IST8310_I2C_ADDR << 1), addr, I2C_MEMADD_SIZE_8BIT, data, len, 10);
}

void WriteMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len) {
    HAL_I2C_Mem_Write(&IST8310_I2C, (IST8310_I2C_ADDR << 1), addr, I2C_MEMADD_SIZE_8BIT, data, len, 10);
}

void ReadIST8310Data(ist8310_raw_data_t* meg_data) {
    uint8_t buf[6];
    int16_t temp_ist8310_data = 0;
    ReadMultiDataFromIST8310(IST8310_DATA_XL_ADDR, buf, 6);
    temp_ist8310_data = (int16_t)((buf[1] << 8) | buf[0]);
    meg_data->x = MAG_SEN * temp_ist8310_data;
    temp_ist8310_data = (int16_t)((buf[3] << 8) | buf[2]);
    meg_data->y = MAG_SEN * temp_ist8310_data;
    temp_ist8310_data = (int16_t)((buf[5] << 8) | buf[4]);
    meg_data->z = MAG_SEN * temp_ist8310_data;
}

ist8310_error_e VerifyMegId(uint8_t* id) {
    *id = ReadSingleDataFromIST8310(IST8310_CHIP_ID_ADDR);
    if (*id != IST8310_CHIP_ID_VAL) {
        return MEG_ID_ERROR;
    } else {
        return IST8310_NO_ERROR;
    }
}

```

`ist8310.h`

```
/**
 * @Author         : Minghang Li
 * @Date           : 2022-12-03 14:29
 * @LastEditTime   : 2022-12-03 16:49
 * @Note           :
 * @Copyright(c)   : Minghang Li Copyright
 */
#pragma once

#include <stdint.h>

typedef struct ist8310_raw_data_t {
    float x;
    float y;
    float z;
} ist8310_raw_data_t;

typedef enum ist8310_error_e {
    IST8310_NO_ERROR = 0x00,
    MEG_ID_ERROR = 0x01,
} ist8310_error_e;

typedef struct ist8310_data_t {
    uint8_t chip_id;
    ist8310_raw_data_t meg_data;
    ist8310_error_e meg_error;
} ist8310_data_t;

/*-----整形向uT转换-----*/
#define MAG_SEN 0.3f

/*-----I2C接口定义-----*/
#define IST8310_I2C_ADDR 0x0E
#define IST8310_I2C hi2c3

/*-----GPIO口定义-----*/
#define IST8310_GPIOx GPIOG
#define IST8310_GPIOp GPIO_PIN_6

void IST8310_INIT(ist8310_data_t* ist8310_data);

// 基础读取函数
uint8_t ReadSingleDataFromIST8310(uint8_t addr);
void WriteSingleDataFromIST8310(uint8_t addr, uint8_t data);
void ReadMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len);
void WriteMultiDataFromIST8310(uint8_t addr, uint8_t* data, uint8_t len);

// 功能函数
void ReadIST8310Data(ist8310_raw_data_t* meg_data);

// 校验函数
ist8310_error_e VerifyMegId(uint8_t* id);

```

`ist8310reg.h`

```
/**
 * @Author         : Minghang Li
 * @Date           : 2022-12-03 15:27
 * @LastEditTime   : 2022-12-03 16:53
 * @Note           :
 * @Copyright(c)   : Minghang Li Copyright
 */
#pragma once

/*-----IST8310寄存器地址-----*/
#define IST8310_CHIP_ID_ADDR 0x00
#define IST8310_CHIP_ID_VAL 0x10

#define IST8310_STAT1_ADDR 0x02

#define IST8310_DATA_XL_ADDR 0x03
#define IST8310_DATA_XH_ADDR 0x04
#define IST8310_DATA_YL_ADDR 0x05
#define IST8310_DATA_YH_ADDR 0x06
#define IST8310_DATA_ZL_ADDR 0x07
#define IST8310_DATA_ZH_ADDR 0x08

#define IST8310_STAT2_ADDR 0x09

#define IST8310_CNTL1_ADDR 0x0A
#define IST8310_CNTL1_SLEEP 0x00
#define IST8310_CNTL1_SINGLE 0x01
#define IST8310_CNTL1_CONTINUE 0x0B

#define IST8310_CNTL2_ADDR 0x0B
#define IST8310_STAT2_NONE_ALL 0x00

#define IST8310_SELF_CHECK_ADDR 0x0C

#define IST8310_TEMPL_ADDR 0x1C
#define IST8310_TEMPH_ADDR 0x1D

#define IST8310_AVGCNTL_ADDR 0x41
#define IST8310_AVGCNTL_TWICE 0x09
#define IST8310_AVGCNTL_FOURTH 0x12
```

效果如下：
![image-20221203171539401](https://git.nrs-lab.com/lmh-group/picgo-pic/uploads/5b8129bb23a229533db580c2a7b511ba/202212031715444.png)
